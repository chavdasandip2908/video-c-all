<!DOCTYPE html>
<html>
  <head>
    <title>Simple Video Call App</title>
    <style>
      /* Basic styling for better layout */
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
        background-color: #f0f2f5;
      }
      h1 {
        color: #333;
      }
      #videoContainer {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        flex-wrap: wrap; /* Allow videos to wrap on smaller screens */
        justify-content: center;
      }
      video {
        width: 45vw; /* Make videos take up about half the viewport width */
        max-width: 480px; /* Max width for larger screens */
        height: auto;
        border: 2px solid #007bff;
        background-color: #000; /* Black background for no video */
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      #localVideo {
        border-color: #28a745; /* Different color for local video */
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }
      button:hover {
        background-color: #0056b3;
      }
      #messages {
        margin-top: 20px;
        font-size: 14px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h1>Video Call</h1>

    <div id="videoContainer">
      <video id="localVideo" autoplay muted></video>
      <video id="remoteVideo" autoplay></video>
    </div>

    <button id="startBtn">Start Call</button>
    <div id="messages"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      // Initialize Socket.IO connection
      const socket = io();
      // Define a fixed room ID for simplicity. In a real app, this would be dynamic.
      const roomId = "demo-room";

      // Get references to HTML video elements and the start button
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const startBtn = document.getElementById("startBtn");
      const messagesDiv = document.getElementById("messages");

      // WebRTC related variables
      let peerConnection; // Represents the peer-to-peer connection
      let localStream; // Holds the local media stream (camera/mic)
      // Stores ICE candidates received before the RTCPeerConnection is ready
      let pendingCandidates = [];

      // WebRTC configuration (STUN server for NAT traversal)
      const config = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" }, // Google's public STUN server
        ],
      };

      // --- 1. Get User Media (Camera/Mic) ---
      // Request access to the user's camera and microphone
      // This runs immediately when the page loads to get your local stream ready
      navigator.mediaDevices
        .getUserMedia({ video: true, audio: true })
        .then((stream) => {
          // If successful, assign the stream to the local video element
          localStream = stream;
          localVideo.srcObject = stream;
          logMessage("Local media access granted.");

          // After getting local media, join the Socket.IO room
          socket.emit("join-room", roomId);

          // Enable the start button and set its click handler
          startBtn.onclick = () => {
            // Only start the call if a peer connection hasn't been established yet
            if (!peerConnection) {
              startCall();
              logMessage("Attempting to start call...");
              startBtn.disabled = true; // Disable button after starting call attempt
            }
          };
        })
        .catch((error) => {
          // Handle cases where video/audio access is denied or unavailable
          logMessage(
            "Could not get local media (video/audio). Attempting with audio only if available or no media."
          );
          console.error("Error accessing media devices: ", error);

          // Try to get audio only if video failed
          navigator.mediaDevices
            .getUserMedia({ video: false, audio: true })
            .then((stream) => {
              localStream = stream;
              localVideo.srcObject = stream; // Still set, but will just be audio (visuals will be black)
              logMessage("Local media access granted (audio only).");
              socket.emit("join-room", roomId);
              startBtn.onclick = () => {
                if (!peerConnection) {
                  startCall();
                  logMessage("Attempting to start call (audio only)...");
                  startBtn.disabled = true;
                }
              };
            })
            .catch((audioError) => {
              logMessage("No media (video or audio) access. Cannot make call.");
              console.error("Error accessing audio devices: ", audioError);
              startBtn.disabled = true; // Disable button if no media is available
            });
        });

      // --- 2. Socket.IO Event Handlers ---
      // These handle signaling messages exchanged via the server

      // When another user joins the same room
      socket.on("user-joined", async () => {
        logMessage("Another user joined the room. Creating offer...");
        // If we haven't started a call yet, start it now
        if (!peerConnection) {
          startCall();
        }

        // Create an SDP offer (Session Description Protocol)
        const offer = await peerConnection.createOffer();
        // Set the local description of the RTCPeerConnection to this offer
        await peerConnection.setLocalDescription(offer);
        // Send the offer to the other peer via the signaling server
        socket.emit("offer", { offer, room: roomId });
        logMessage("Offer sent.");
      });

      // When an offer is received from another peer
      socket.on("offer", async ({ offer }) => {
        logMessage("Received offer. Creating answer...");
        // If we haven't started a call yet, start it now
        if (!peerConnection) {
          startCall();
        }

        // Set the remote description of the RTCPeerConnection to the received offer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        // Create an SDP answer in response to the offer
        const answer = await peerConnection.createAnswer();
        // Set the local description to this answer
        await peerConnection.setLocalDescription(answer);
        // Send the answer to the other peer via the signaling server
        socket.emit("answer", { answer, room: roomId });
        logMessage("Answer sent.");
      });

      // When an answer is received from another peer
      socket.on("answer", async ({ answer }) => {
        logMessage("Received answer.");
        // Set the remote description to the received answer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        logMessage("Call established!");
      });

      // When an ICE candidate is received from another peer
      socket.on("ice-candidate", ({ candidate }) => {
        logMessage("Received ICE candidate.");
        // If the peer connection is already set up, add the candidate directly
        if (peerConnection) {
          peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } else {
          // Otherwise, store it in pending candidates to be added later
          pendingCandidates.push(candidate);
        }
      });

      // --- 3. WebRTC Call Setup Function ---
      function startCall() {
        // Create a new RTCPeerConnection instance
        peerConnection = new RTCPeerConnection(config);

        // Add local media tracks to the peer connection
        // This makes your audio/video available to the other peer
        if (localStream) {
          localStream.getTracks().forEach((track) => {
            peerConnection.addTrack(track, localStream);
          });
          logMessage("Added local media tracks to peer connection.");
        } else {
          logMessage("No local media stream to add to peer connection.");
        }

        // Event: When a remote track is received (from the other peer)
        peerConnection.ontrack = (event) => {
          // Set the received stream as the source for the remote video element
          if (remoteVideo.srcObject !== event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            logMessage("Remote stream received!");
          }
        };

        // Event: When an ICE candidate is generated locally
        // ICE candidates describe network addresses (IPs, ports) for direct connection
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            // Send the candidate to the other peer via the signaling server
            socket.emit("ice-candidate", {
              candidate: event.candidate,
              room: roomId,
            });
            logMessage("Sent ICE candidate.");
          }
        };

        // Event: Peer connection state changes
        peerConnection.onconnectionstatechange = (event) => {
          logMessage(`Peer connection state: ${peerConnection.connectionState}`);
          if (peerConnection.connectionState === 'connected') {
            logMessage("Peer connection established!");
          } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
            logMessage("Peer connection disconnected or failed. Call ended.");
            // Optionally, re-enable start button or prompt for reconnection
            startBtn.disabled = false;
            startBtn.innerText = "Start New Call";
          }
        };


        // After the peer connection is set up, add any pending ICE candidates
        // (candidates that arrived before peerConnection was initialized)
        pendingCandidates.forEach((candidate) => {
          peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        });
        // Clear the pending candidates array
        pendingCandidates = [];
      }

      // Helper function to display messages to the user
      function logMessage(message) {
        const p = document.createElement("p");
        p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        messagesDiv.prepend(p); // Add new messages at the top
        // Keep only the last few messages to avoid clutter
        if (messagesDiv.children.length > 5) {
          messagesDiv.removeChild(messagesDiv.lastChild);
        }
      }

      // Handle user leaving/disconnecting (optional, but good for cleanup)
      socket.on("user-left", (userId) => {
        logMessage(`User ${userId} left the room.`);
        // Optionally, clear remote video or reset peer connection
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject = null;
        }
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
          logMessage("Peer connection closed due to user leaving.");
          startBtn.disabled = false;
          startBtn.innerText = "Start Call";
        }
      });

      socket.on("user-disconnected", (userId) => {
        logMessage(`User ${userId} disconnected.`);
        // Same as user-left, but specific to full disconnection
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject = null;
        }
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
          logMessage("Peer connection closed due to user disconnecting.");
          startBtn.disabled = false;
          startBtn.innerText = "Start Call";
        }
      });
    </script>
  </body>
</html>